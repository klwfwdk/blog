---
title: 前端安全面试小抄
date: 2022-01-09
tags:
 - 安全
categories:
 - 面试总结
---
# 前端安全面试小抄
> 参考内容
> 
> [【面试篇】寒冬求职之你必须要懂的Web安全](https://juejin.cn/post/6844903842635579405#heading-1)
> 
> [什么是HSTS，为什么要使用它？](https://zhuanlan.zhihu.com/p/130946490)
> 
> [8大前端安全问题](https://insights.thoughtworks.cn/eight-security-problems-in-front-end/)
## 前端安全类型
1. XSS 跨站脚本攻击
2. CSRF 跨站请求伪造
3. Clickjacking 点击劫持
4.  MIME 类型混淆攻击("X-Content-Type-Options: nosniff")
5.  第三方包漏洞
6.  HTTPS强制降级
7.  本地数据泄漏（不要存储关键信息到本地）
8.  CDN劫持

## XSS 跨站脚本攻击
XSS(cross-site scripting，跨站脚本攻击)是一种代码注入攻击。攻击者将在网站上注入恶意代码，当被攻击者登陆登陆网站时就会执行这些恶意代码。存在的危害有
1. 读取cookie session token等敏感信息
2. 钓鱼
3. 蠕虫攻击

其本质是恶意代码未经过过滤，与正常的代码混在一起被浏览器执行了。而浏览器无法区分两者的来源从而获得了更高的权限。

按照攻击的来源分为三类
1. 反射型
2. 储存型
3. DOM型

### 反射型
攻击步骤如下: 
1. 攻击者构造出特殊的 URL，其中包含恶意代码。
2. 用户打开带有恶意代码的 URL 时，网站服务端将恶意代码从 URL 中取出，拼接在 HTML 中返回给浏览器。
3. 用户浏览器接收到响应后解析执行，混在其中的恶意代码也被执行。
4. 恶意代码窃取用户数据并发送到攻击者的网站，或者冒充用户的行为，调用目标网站接口执行攻击者指定的操作。
如上述操作可以推出，这类攻击常见于网站搜索，跳转等特殊场景。需要用户主动打开恶意URL才能生效。也可能通过构造表单提交页面引导用户点击对post请求进行反射式XSS。
解决方案为对url查询对参数进行转译后再输出到页面

### 储存型
储存型常见于博客或者点评页面。用户通过提交带有恶意代码的内容到服务器，然后通过服务器渲染时在被攻击者的电脑上运行恶意代码
解决方案为在用户提交内容的时候进行转义

### dom型
dom型其实在前后端分离的今天，跟储存型很类似，只是一个入库，一个不入库。防范方式也类似，只是前两种可由后端进行处理。而dom型只能够由前端进行处理。

### 防范方式
除了转译还有以下方式进行防范
1. 设置严格的csp(content-security-policy，内容安全策略)，有以下好处
   1. 禁止加载外域代码，防止复杂的攻击逻辑。
   2. 禁止外域提交，网站被攻击后，用户的数据不会泄露到外域。
   3. 禁止内联脚本执行（规则较严格，目前发现 GitHub 使用）。
   4. 禁止未授权的脚本执行（新特性，Google Map 移动版在使用）。
   5. 合理使用上报可以及时发现 XSS，利于尽快修复问题。
2. 限制输入内容的长度
3. 限制输入内容，比如只能是数字活着不能包含特殊字符
4. HTTP-only Cookie，禁止js读取敏感的cookie

## CSRF (cross-site request forgery) 跨站请求伪造

攻击者诱导受害者进入第三方网站，在第三方网站中，向被攻击网站发送跨站请求。利用受害者在被攻击网站已经获取的注册凭证，绕过后台的用户验证，达到冒充用户对被攻击的网站执行某项操作的目的。

攻击流程如下
1. 受害者登录A站点，并保留了登录凭证（Cookie）。
2. 攻击者诱导受害者访问了站点B。
3. 站点B向站点A发送了一个请求，为了避免跨域一般是form请求，浏览器会默认携带站点A的Cookie信息。
4. 站点A接收到请求后，对请求进行验证，并确认是受害者的凭证，误以为是无辜的受害者发送的请求。
5. 站点A以受害者的名义执行了站点B的请求。
6. 攻击完成，攻击者在受害者不知情的情况下，冒充受害者完成了攻击。

> 一个域名下的js 未经允许不能读取另一个域名的内容，但是浏览器不会阻止你向另一个域名发请求

### 防范方式
1. 添加验证码，防止请求的自动发送
2. 检测Refere，但是这个字段可以被伪造
3. 使用Token，而不是cookie。
4. Samesite cookie
   1. 在设置cookie的时候通过`Samesite`属性可以防止B伪造请求带上自己的cookie，但是存在兼容性问题。
   2. 这个字段可以为`Strict`,所有请求都无法获取cookie，可以为`Lax`，这样的话GET OPTIONS HEAD可以 其他不行。

## 点击劫持
点击劫持是在网页中隐藏一个透明的iframe， 用外层假页面诱导用户点击，但是是在隐藏的页面上触发了点击事件产生的用户不知情的操作。

防范方式，核心就一条： 阻止页面在不同源的页面中加载。
1. frame busting，用人话说就是在网页中判断自己的location和top的是否同源 同源就进行破坏
2. X-Frame-Options: 设置页面在iframe下是否允许加载。
   1. DENY: 禁止所有
   2. SAMEORIGIN: 允许同源加载
   3. ALLOW-FROM: 可以自定义允许的页面地址

## HTTPS强制降级，然后进行中间人攻击
就算是使用了HTTPS,攻击者通过特殊手段进行了降级，然后进行中间人攻击。一般为了向下兼容，我们会通过重定向将http的请求转到https上。但是在攻击者存在时，通过特殊手段阻止了这次重定向结果拦截了，并且代替客户端和服务器端进行后续的通信。
解决方案是通过设置`HSTS`
```
Strict-Transport-Security: max-age=31536000; includeSubDomains; preload
```
意思是每个链接到此域和其子域的请求 在 `max-age`秒内，只能给被https链接，任何使用http加载资源的请求，都必须使用https进行替代。如果https不可用，则必须停止链接。
这个方法有两个问题，一个是如果证书失效会导致页面完全无法被访问，第二个是第一次访问不收到保护，如果一开始中间人就存在，HSTS响应头也可以被修改，所以不可信。

针对第一次 有个备用方法，就是由google组织的HSTS preload list。开发者可以在配置好HSTS后去 [https://hstspreload.org/](https://hstspreload.org/) 添加自己的域名。这个列表会被所有主流浏览器硬编码到浏览器程序内，所以设置以后生效和失效都需要较长的时间。